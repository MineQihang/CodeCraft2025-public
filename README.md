# CodeCraft2025 / [2025华为软件精英挑战赛](https://developer.huaweicloud.com/codecraft2025)

我们是来自江山赛区的“再吃一颗苹果”赛队，很高心能在今年的软挑斩获季军。下面记录我们本次比赛采取的策略和一些心得体会，希望对大家有所帮助。

## 1 解题策略

### 1.1 初赛

分析可以知道，删除策略不需要进行优化，我们需要优化写策略和读策略。

*注：由于讨论和编码使用label表示题中的标签（tag），因此下面都使用label。*

#### （1）写策略

总体来说，写策略比较简单，将一个磁盘平分为3部分，第一部分存放对象的第一个副本，第二部分存第二个副本，第三个部分存第三个副本。

现在考虑对于前1/3的数据内部该怎么排布（因为后面的部分都不会被读，所以无需处理排布问题）。下面有两个选择：

- 把所有label的数据都会存到1/3里。
- 一个1/3中只存放部分label的数据。

考虑到后面的方法难以实现，容易写爆盘，且要考虑磁头的负载均衡，我们采用前者。这样的方法具有以下优点：

- 不用考虑负载均衡，总是均衡的。
- 不用考虑label分配到哪个盘上的问题。

在基本策略确定后，我们需要考虑的是如何排布，要达到的目的就是**让后续读操作越快越好**！

题目中说，相同label的数据有类似的读周期。那我们就让label一样的都放到一起，基本思路就是在这1/3的区域内划分出16个小区域，每个区域对应一个label的数据。那如何实现？我们需要考虑两个点：

1. label应该有什么顺序？
2. 每个label应该分配多大的空间？

首先是第1个问题，我们可以考虑将读序列相似的label尽量放到一起，可以计算两个label读序列的相似度来衡量两个label之间的距离，那现在的问题转化为了给定16个label，如何只遍历一次16个label，得到距离最小的一个顺序。这是典型的TSP问题，考虑到节点数量比较少，可以用DP做。但由于这个相似度只是粗糙的估计，用最优化算法求和求一个次优解对应于最终分数的差距并不总是正相关的，也就是说，一个次优解就可以相对随机分配有更好的结果了，最优解不一定可以得到更好的最终分数。这里面有一个小trick，我们计算两个读序列相似度时，需要做一下归一化，不然算出来的相似度（使用L2正则）不能反映两个序列的趋势相似性。这里的归一化我们可以先除以最大值，然后判断有无读请求（是否>0.1），将数据划归到0或1，这样计算的相似性更能反应相似。

第2个问题，用峰值对象数直接求即可。有一个小trick，[0.8, 1.2]。

下面，还需要解决一个问题，一个对象究竟应该存到哪个disk中呢？step最小的即可。



#### （2）读策略

到顶就jump

中间全pass就看能不能直接jump

暴力搜索计算r-p序列



### 1.2 复赛

write+busy+gc应该联合到一起优化

read貌似不需要优化了



### 1.3 决赛

xxx

#### Round 1





#### Round 2





## 2 代码结构

```
├─final
│  ├─docs
│  ├─src
│  └─test
├─preliminary
│  ├─docs
│  ├─src
│  └─test
└─semifinal
    ├─docs
    ├─src
    └─test
```





## 3 心得体会





## 4 友情链接

- 赛事首页：https://developer.huaweicloud.com/codecraft2025
- 冠军粤港澳赛区“Tom and Jerry”赛队的仓库：https://github.com/sunkafei/huawei-software-challenge2025（咖啡佬太强了，膜拜！👍）
- 软件开发最佳实践奖获得者京津东北赛区“Pearcat”赛队的仓库：https://github.com/churuikai/craft2025_pearcat（代码好看，整活小能手😄）









