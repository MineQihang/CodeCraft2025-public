# CodeCraft2025 / [2025华为软件精英挑战赛](https://developer.huaweicloud.com/codecraft2025)

我们是来自江山赛区的“再吃一颗苹果”赛队，很高心能在今年的软挑斩获季军。下面记录我们本次比赛采取的策略和一些心得体会，希望对大家有所帮助。

## 1 解题策略

### 1.1 初赛

分析可以知道，删除策略不需要进行优化，我们需要优化写策略和读策略。

*注：由于讨论和编码使用label表示题中的标签（tag），因此下面都使用label。*

#### （1）写策略

总体来说，写策略比较简单，将一个磁盘平分为3部分，第一部分存放对象的第一个副本，第二部分存第二个副本，第三个部分存第三个副本。

现在考虑对于前1/3的数据内部该怎么排布（因为后面的部分都不会被读，所以无需处理排布问题）。下面有两个选择：

- 把所有label的数据都会存到1/3里。
- 一个1/3中只存放部分label的数据。

考虑到后面的方法难以实现，容易写爆盘，且要考虑磁头的负载均衡，我们采用前者。这样的方法具有以下优点：

- 不用考虑负载均衡，总是均衡的。
- 不用考虑label分配到哪个盘上的问题。

在基本策略确定后，我们需要考虑的是如何排布，要达到的目的就是**让后续读操作越快越好**！

题目中说，相同label的数据有类似的读周期。那我们就让label一样的都放到一起，基本思路就是在这1/3的区域内划分出16个小区域，每个区域对应一个label的数据。那如何实现？我们需要考虑两个点：

1. label应该有什么顺序？
2. 每个label应该分配多大的空间？

首先是第1个问题，我们可以考虑将读序列相似的label尽量放到一起，可以计算两个label读序列的相似度来衡量两个label之间的距离，那现在的问题转化为了给定16个label，如何只遍历一次16个label，得到距离最小的一个顺序。这是典型的TSP问题，考虑到节点数量比较少，可以用DP做。但由于这个相似度只是粗糙的估计，用最优化算法求和求一个次优解对应于最终分数的差距并不总是正相关的，也就是说，一个次优解就可以相对随机分配有更好的结果了，最优解不一定可以得到更好的最终分数。这里面有一个小trick，我们计算两个读序列相似度时，需要做一下归一化，不然算出来的相似度（使用L2正则）不能反映两个序列的趋势相似性。这里的归一化我们可以先除以最大值，然后判断有无读请求（是否>0.1），将数据划归到0或1，这样计算的相似性更能反应相似。

第2个问题，用峰值对象数直接求即可。有一个小trick，[0.8, 1.2]。

下面，还需要解决一个问题，一个对象究竟应该存到哪个disk中呢？step最小的即可。



#### （2）读策略

到顶就jump

中间全pass就看能不能直接jump

暴力搜索计算r-p序列



### 1.2 复赛

write+busy+gc应该联合到一起优化

read貌似不需要优化了



### 1.3 决赛

xxx

#### Round 1

在决赛题目中，round1无法再预先获知16个label在各个slice的数量和读取信息，且在写入时，将有约65%对象将不再给出label（下文将被称作label0对象）。因此，适当地处理这些label0对象将十分关键。

显然，对相同label的对象进行聚类是提升性能的关键操作。因此，在round1中需要预测label0对象的真实label，并利用gc操作对已写入的对象移动到正确的位置中。我们的预测策略主要基于各个label的**读请求的频次**特征。这个频次定义为：**当前timestamp中label读取的次数/当前timestamp中label的总obj数量**。要预测label时，只需匹配从对象写入时间到当前时间（或删除时间）间的读请求频次曲线即可。正确率约可达95%

对于写的部分，因为无法再预先获知各个label的写入量情况，在round1中我们不再为各个label按比例分配写入空间，而是分配相同大小的空间给各个label。与此同时，为了配合剩下65%的label0空间和我们在复赛中已经基本完善的$2 \times 1/6$存储框架，我们对磁盘进行如下初始化：

1. 每个盘只使用前1/3存储副本一，剩下2/3存储副本二三但不被读取；
2. 每个盘的1/3被分为两个1/6区域，分别被每个盘上的两个磁头读取，每个1/6区域里只分配8个label的存储区域；
3. 每个label均分每个盘1/3空间的35%，并且在各个label存储区域间安排一个长度为100的**gap**存储保存label0对象。1/6区域的划分剩余的区域也用于存放label0对象；

初始化过程中的**gap**其实是在优化过程中会发生分歧的点。当gap越小时，整个1/6区间中围绕各个label区间存储的块会更紧密，前期存储数量低时jump更少；当gap越大时，各个label区间间隔的距离更大，gc处理存放位置不合适的label对象时将有更多空间用于交换。在我们的实现中，各个label区间间有一个长为100的gap，对于长度为16384的盘来说，此时有约少于一半的label0空间为gap，约多于一半的label0空间存在于1/6盘区间的末尾。

在写入时，确定label的对象将从label空间中间向两边写，label0对象从前向后负载均衡地在各个gap和末尾的连续空间中写。

对请求的提前放弃，我们有两种处理方法：

* 统计前一段时间中各个label的读取情况，对于读取频率低于阈值的label，在收到读请求时直接报busy
* 统计磁头读速并计算busy_score，并在读速低于阈值时选择放弃对应label的请求



#### Round 2





## 2 代码结构

```
├─final
│  ├─docs
│  ├─src
│  └─test
├─preliminary
│  ├─docs
│  ├─src
│  └─test
└─semifinal
    ├─docs
    ├─src
    └─test
```





## 3 心得体会





## 4 友情链接

- 赛事首页：https://developer.huaweicloud.com/codecraft2025
- 冠军粤港澳赛区“Tom and Jerry”赛队的仓库：https://github.com/sunkafei/huawei-software-challenge2025（咖啡佬太强了，膜拜！👍）
- 软件开发最佳实践奖获得者京津东北赛区“Pearcat”赛队的仓库：https://github.com/churuikai/craft2025_pearcat（代码好看，整活小能手😄）









